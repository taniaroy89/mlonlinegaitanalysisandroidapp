\chapter{Applicativo Android}
%\myChapter{Applicativo Android}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduzione}%descrivere cosa fa a grandi linee %%%%%%%%%%%%%%%%%%%%%%%%%                           INTRODUZIONE

La seconda parte del lavoro, è relativa all'implementazione di algoritmi di segmentazione online su uno Smartphone Android. L'applicativo in oggetto,  sulla base di un modello HMM addestrato offline (vedi sezione \ref{sec:creazione_addestramento_modello}), impiega una versione dell'algoritmo di Viterbi \cite{short_time_viterbi_online_hmm_deconding} per elaborare a run-time i dati giroscopici acquisiti dalla IMU (e trasferiti via Bluetooth), effettuando la segmentazione e consentendo output di tipo grafico (colorando in modo differente la traccia del segnale giroscopico in funzione della fase del cammino), e di data logging. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Metodologia di programmazione usata: Agile}%agile %%%%%%%%%%%%%%%%%         METODOLOGIA DI PROGRAMMAZIONE
\label{sec:agile}
Per l'implementazione dell'algoritmo di Viterbi e le funzioni utilizzate nella fase di analisi del segnale, è stata utilizzata una tecnica nota come Agile Programming. Una tecnica che permette lo sviluppo di programmi in cicli di lavoro iterativi ed incrementali in termini di funzionalità. 
\begin{enumerate}
	\item Scrittura di uno Unit Test\footnote{Per Unit si intende la più piccola parte di un programma che può essere testata, nei linguaggi orientati ad oggetti un metodo costituisce un'unità. Per Unit testing si intende la verifica del funzionamento di singole Unit. }. Lo Unit Test istanza l'oggetto dalla classe da testare, ed invoca il metodo con valori per i quali è noto il comportamento (teorico) del metodo da testare.\\
Il test viene eseguito, per la prima volta, prima di aver implementato il metodo da testare, ed ovviamente fallisce\footnote{Eclipe IDE \tm utilizza il framework JUnit che semplifica la gestione degli Unit Test.}. Il passo successivo è di implementare il minimo indispensabile per far funzionare il test. Se il test viene superato dal codice scritto, viene scritto un altro test, ed un altro pezzo di codice, iterando la procedura finché non si ha tutto il programma desiderato.\\ 
A titolo di esempio di seguito verrà illustrato lo sviluppo della classe che gestisce le operazioni di tipo statistico:
\begin{lstlisting}[language=java, style=eclipse, caption=Sviluppo di una classe mediante la tecnica di programmazione Agile, label=code:agile1]
// la classe da costruire 
public class StatisticsOperations{...}
// l'insieme di test
public class StatisticsOperationsTest extends TestCase {...}
\end{lstlisting}


Le operazioni necessarie per lavorare sulle HMM erano: 
\begin{itemize}
	\item verificare la validità di valori di probabilità
	\item verificare la completezza di un insieme di alternative probabilistiche
	\item calcolare la Probabilità di un dato assumendo quanto estratto da una distribuzione Normale ($ \mathcal{N}(x,\mu, \sigma)$) con media $\mu$ e varianza $\sigma^2$ note.
\end{itemize}
Creazione delle le firme dei metodi
\begin{lstlisting}[language=java, style=eclipse, caption=Firme dei metodi da implementare, label=code:agile2]
public class StatisticsOperations{	
	public static boolean areCompleteProbabilisticAlternatives(ArrayList<Object> alternatives) {...}
	public static boolean isValidProbabilityValue(double value) {...}
	public static double gaussian(double x, double mu, double sigma_square) {...}
}
\end{lstlisting}
\item Creazione di un test vuoto (destinato a fallire).
\item Implementazione dei test per cinque casi rappresentativi dei degli intervalli esterni ed interni a quello di riferimento (0,1).

\begin{lstlisting}[language=java, style=eclipse, caption=Casi di test di contorno, label=code:agile3]
public class StatisticsOperationsTest extends TestCase {
	... // metodi setUp e tearDown che per ora non uso
	
	public void testIsMinusOneACorrectProbabilityValue() {
		boolean expected = false;
		boolean actual = StatisticsOperations.isValidProbabilityValue(-1);
		assertEquals(expected, actual);
	}
	public void testIsZeroACorrectProbabilityValue() {
		boolean expected = true;
		boolean actual = StatisticsOperations.isValidProbabilityValue(0);
		assertEquals(expected, actual);
	}
	public void testIsPointFiveACorrectProbabilityValue() {
		boolean expected = true;
		boolean actual = StatisticsOperations.isValidProbabilityValue(.5);
		assertEquals(expected, actual);
	}
	
	public void testIsOneACorrectProbabilityValue() {
		boolean expected = true;
		boolean actual = StatisticsOperations.isValidProbabilityValue(1);
		assertEquals(expected, actual);
	}
	
	public void testIsTwoACorrectProbabilityValue() {
		boolean expected = false;
		boolean actual = StatisticsOperations.isValidProbabilityValue(2);
		assertEquals(expected, actual);
	}
	
	public void testIsRandNumACorrectProbabilityValue() {
		boolean expected = false;
		double randomProbabilityValue = Math.random();
		if (randomProbabilityValue >= 0 && randomProbabilityValue <= 1){
			expected = true;
		}
		boolean actual = StatisticsOperations.isValidProbabilityValue(randomProbabilityValue);
		assertEquals(expected, actual);
	}

}
\end{lstlisting}

\item Sviluppo del corpo del metodo che si sta testando. Questa fase (la più importante) è notevolmente agevolata dalle precedenti. Il programmatore ha chiare la funzione da implementare e le relative problematiche. 
\begin{lstlisting}[language=java, style=eclipse,caption=Implementazione dei metodi da testare, label=code:agile4]
public class StatisticsOperations{	
	public static boolean areCompleteProbabilisticAlternatives(ArrayList<Object> alternatives) {...}
	public static boolean isValidProbabilityValue(double value) {
		if (value >= 0 && value <= 1)
			return true;
		else
			return false;
}
	public static double gaussian(double x, double mu, double sigma_square) {...}
}
\end{lstlisting}
\end{enumerate}
La esecuzione del test sul metodo riscritto porta ad uno dei seguenti esiti:
\begin{enumerate}
	\item superamento di tutti i test, quindi lo sviluppo del metodo è completato,
	\item fallimento di almeno un test, il metodo deve essere corretto ed i test devono essere nuovamente eseguiti.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Organizzazione del programma}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              ORGANIZZAZIONE DEL CODICE
\subsection{Android Manifest} AndroidManifest.xml (vedi Appendice \ref{sec:android_app_structure}) è il file che viene usato come punto di partenza e di riferimento dal compilatore Dalvik (vedi Appendice \ref{sec:dalvik}). 


\begin{lstlisting}[language=XML, style=xmlandroid, caption=AndroidManifest testata, label=code:manifest_permissions]
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
	package="imu.Interface" android:versCode="1" android:versName="1.0">
\end{lstlisting}
Il nome del Java package, serve come identificativo unico per l'applicativo.

\begin{lstlisting}[language=XML, style=xmlandroid,caption=AndroidManifest permessi,label=code:manifest_permissions, firstnumber=3]
	<uses-permission android:name="android.permission.BLUETOOTH" />
	<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
	<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
	<uses-sdk android:minSdkVersion="8" />
	...
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% modifica 24 nov %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dato che il nucleo di Android-OS è Linux (vedi Appendice \ref{app:android}) usa una politica di {Access Control}\footnote{Accesso controllato dell'utente di un filesystem o di un servizio} molto simile. Tutti i servizi che non sono forniti dal contesto di questo particolare applicativo, quindi i servizi che fornisce l'applicativo stesso, e quelli forniti dal sistema operativo per tutti gli applicativi, possono essere utilizzati solo se l'utente da il permesso di utilizzarli. Per questo motivo l'applicativo deve elencare tutte le richieste di permessi di cui necessita. L'elenco deve essere fatto nella porzione iniziale dell'\verb|AndroidManifest|
 Dichiarazione dei permessi che l'applicativo deve avere dall'utente per accedere ad alcune parti dell'API\footnote{ Application Programming Interface: interfaccia ad un codice che viene messo a disposizione come servizio in modo che terzi possano usarlo per sviluppare altro software, avvolte anche in altri linguaggi.
 In dettaglio una API nei linguaggi orientati ad oggetti, sono concepiti come l'insieme di tutti i metodi pubblici che le classi pubbliche offrono.} di Android e per interagire con altri applicativi.
 La riga 4 chiede il permesso di fare la discovery (ricerca) di dispositivi e di associarsi  a dispositivi trovati, la riga precedente invece il permesso di connettersi a dispositivi associati \footnote{L'associazione è la prima connessione, nella quale vi è una forma di identificazione e associazione dei due dispositivi. Per connessione invece si intendono le connessioni successive alla prima, in cui un dispositivo conosce già l'altro e, più rapidamente, possono iniziare una conversazione.}. L'ultimo permesso serve per poter scrivere su un dispositivo d'immagazzinamento esterno, questo ci serve per poter salvare ad esempio l'output dell

 
\begin{lstlisting}[language=XML, style=xmlandroid,caption=AndroidManifest dichiarazione dell'attività principale, label=code:manifest_application, firstnumber=8]
	<application android:icon="@drawable/spinningtop02"
		android:label="@string/app_nameicon" 
		android:name="imu.objects.MailBoxes">
\end{lstlisting}
Vengono dichiarati il nome dell'applicativo, l'icona, ed un'etichetta. In questo punto si dichiara anche il nome dell'oggetto che può essere visibile a livello globale di applicativo. Infatti l'oggetto \verb|MailBoxes| che è un vettore di \verb|MailBox| (vedi \ref{sec:mailbox}) che sono a loro volta utilizzati per lo scambio di dati tra thread.

\begin{lstlisting}[language=XML, style=xmlandroid,caption=AndroidManifes elenco di tutte le attività ,label=code:manifest_activities, firstnumber=11]		
		<activity android:name=".IMUinterface" android:configChanges="orientation">
			<intent-filter>
				<action android:name="android.intent.action.MAIN" />
				<category android:name="android.intent.category.LAUNCHER" />
			</intent-filter>
		</activity>
		<activity android:name=".Saveactivity" android:label="@string/save_name" />
		<activity android:name=".SensSetupactivity" android:label="@string/sens_name" />
		<activity android:name=".Provaactivity" android:label="@string/prova_name" />
		<activity android:name=".EmbeddedSensDataPlottingvActivity"
			android:label="@string/prova_name" android:configChanges="orientation"
			android:theme="@android:style/Theme.NoTitleBar.Fullscreen" />
		<activity android:name=".TemporalDataPlottingvActivity"
			android:configChanges="orientation" android:theme="@android:style/Theme.NoTitleBar.Fullscreen" />
\end{lstlisting}	
Sezione di \verb|AndroidManifest| in cui si elencano i componenti fondamentali (vedi Appendice \ref{sec:android_main_components}) utilizzati nell'applicativo.
Il nostro applicativo, che ha una struttura molto semplice, ed utilizza solo \verb|Activity| ed \verb|Intent|. 
Il l'Activity principale (Main Activity) è \verb|IMUInterface|.\\ 
La dichiarazione di una Activity è composta da un nome e da una classe Java.
Inoltre sono dichiarate altre impostazioni iniziali: se sono gestiti o meno i 2 orientamenti dello schermo, se lo schermo deve essere visualizzato senza la barra dei titoli in testa allo schermo.

\subsection{Codice sorgente}
Tutto il codice sorgente (Java) deve essere contenuto nella cartella \emph{src} del progetto. 
Abbiamo strutturato il codice in 5 package (cartelle di Java):
\begin{itemize}
	\item \textbf{activities}: le Activity, corrispondono indicativamente ciascuna ad una schermata sullo Smartphone,
	\item \textbf{objects} : dati, modelli o contenitori su cui fare operazioni,
	\item \textbf{services}: operazioni fondamentali dell'applicativo, che qui coincidono agli algoritmi che si applicano alla HMM. 
	\item \textbf{tests}: test prodotti dall'utilizzo della metodologia Agile (vedi \ref{sec:agile}),
	\item \textbf{util}: operazioni di supporto al resto del codice. 
\end{itemize} 

\subsection{Risorse}
Le risorse sono costituite da tutti i file che fanno parte dell'applicativo, ma non sono codice sorgente (vedi Appendice \ref{sec:android_app_structure}) vale a dire file xml, immagini, testo ecc. La sezione più importante delle risorse è la cartella \textbf{layout}. Questa contiene una serie di file xml, che in teoria, per ciascuna Activity dovrebbe essere creato un file xml da mettere nella cartella layout, con lo stesso nome della Activity.
\subsubsection{Layout}
Un file di layout (impaginazione) è un documento xml in cui viene descritta la struttura dell'interfaccia utente di una Activity.
Layout deve essere composto di elementi grafici predefiniti in Android oppure deve essere di tipo \verb|Veiw| o  \verb|ViewGoup|\footnote{Sia la View che la ViewGroup appartengono al package android.view e sono componenti importante dell'interfaccia utente}. Ogni file di layout deve contenere esattamente un elemento radice. Ogni elemento grafico ha un identificativo unico, con cui può essere richiamato dal codice sorgente, tramite l'indicizzazione automatica.
Eclipse \tm permette di definire un layout sia in modalità xml che in modalità grafica (WYSIWYG\footnote{What You See Is What You Get}). Ad esempio il layout della activity principale (ImuInterface) è il seguente 
\begin{lstlisting}[language=XML, style=xmlandroid,caption=LinearLayout:impaginazione  della schermata principale,label=code:mainActivity_layout_linear]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
	android:orientation="vertical" android:layout_width="fill_parent"
	android:background="#111111" android:layout_height="fill_parent">
\end{lstlisting}
Un \verb|LinearLayout| è un tipo di layout che può contenere altri layout, in sostanza serve ad organizzare oggetti. Sono impostate alcune delle proprietà (orientamento, larghezza ecc) dell'oggetto.  
\begin{lstlisting}[language=XML, style=xmlandroid,caption=TextView: oggetto contenente testo ,label=code:mainActivity_layout_text, firstnumber=5]
	<TextView android:layout_height="wrap_content" 
		android:text="@string/ImuActivity_title" android:textStyle="bold"
		android:id="@+id/AppName" android:layout_width="320dip">
	</TextView>
\end{lstlisting}	
Questo è un oggetto che contiene testo non modificabile dall'utente. Qui viene visualizzato il titolo della schermata, contenuto nella variabile di stringa \verb|"@string/ImuActivity_title"|.

\begin{lstlisting}[language=XML, style=xmlandroid,caption=EditText:oggetto contenente campi di testo modificabili,label=code:mainActivity_layout_text, firstnumber=9]
	<EditText android:id="@+id/editText1" 
		android:layout_height="wrap_content" 
		android:layout_width="match_parent">
	</EditText>
	<EditText android:id="@+id/editText2"
		android:layout_height="wrap_content" 
		android:layout_width="match_parent">
	</EditText>
	....
\end{lstlisting}	
Vi sono subito sotto il titolo della schermata, quattro campi di testo (di cui sono riportate solo 2 a titolo illustrativo). 


\begin{lstlisting}[language=XML, style=xmlandroid,caption=Esempio di LinearLayout contenente un Button,label=code:mainActivity_layout_text, firstnumber=25]
	<LinearLayout android:background="#111111"
		android:layout_height="fill_parent" 
		android:layout_weight="1"
		android:layout_width="fill_parent" 
		android:orientation="horizontal">
		...
		<Button android:id="@+id/button2" android:layout_height="wrap_content"
			android:text="Start" android:gravity="center_vertical|center_horizontal"
			android:layout_width="55dip">
		</Button>
		...
	</LinearLayout>
	...
\end{lstlisting}

La parte seguente della schermata, percorrendola dall'alto verso il basso, è un altro \verb|LineraLayout| contenente altri campi di testo e bottoni.\\
La schermata risultante dal layout è quella dell'immagine \ref{fig:main_activity}.
\begin{figure}
	\centering
		\includegraphics[width=.7\textwidth]{imgs/MenuActivity.jpg}
	\caption{Schermata della Activity iniziale dell'applicativo}
	\label{fig:main_activity}
\end{figure}
\subsubsection{File grafici}
I file grafici sono distribuiti su tre cartelle \textbf{drawable-hdpi}, \textbf{drawable-ldpi},\textbf{drawable-mdpi} in cui salvare formati a definizioni diverse delle stesse immagini per diversi dispositivi. 
\subsubsection{Valori}
Il file più importante in questa cartella è \verb|strings.xml| in cui vengono salvate tutte le stringhe da visualizzare sulle varie schermate. L'utilità maggiore di mantenere le stringhe in un file unico, è l'internazionalizzazione dell'applicativo. Con il tipo di mercato mondiale che hanno gli applicativi Android, avere il testo tradotto in più lingue è necessario.
\subsubsection{Altri File}
Qualunque tipi di file, che non sia compatibile con quelli menzionati precedentemente, vanno nella cartella \verb|raw|. Ad esempio, in fase di sviluppo, per testare l'algoritmo di Viterbi, abbiamo usato un file contenente dati di un giroscopio, acquisito nella fase precedente del lavoro. 
\subsection{Librerie}
Le librerie usate sono quelle di Android 2.2 (vedi Appendice \ref{sec:lib_Android}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Funzionamento}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                         FUNZIONAMENTO 
\subsection{Interfaccia}
La linea guida per lo sviluppo della UI (Interfaccia Utente) è stata quella della massima ergonomicità, in linea con la filosofia di sviluppo di interfacce utente di Android. \\
La navigazione tra le schermate dell'applicativo è guidata da widget che sono oggetti grafici della UI di un programma, che hanno lo scopo di facilitare all'utente l'interazione con il programma. \\
All'avvio del programma, viene visualizzato sullo schermo del dispositivo, un menu dal quale è possibile 

\begin{figure}
	\centering
		\includegraphics[width=1\textwidth]{imgs/interfacciaApplicativo.jpg}
	\caption{Collegamento fra le schermate dell'applicativo}
	\label{fig:app_UI}
\end{figure}

\subsection{Comunicazione Bluetooth}
\label{sec:bluetooth_adapter}
\verb|BluetoothAdapter|
Rappresenta l'adattatore Bluetooth del dispositivo locale e permette di fare le operazioni più importanti sullo stesso:
\begin{itemize}
	\item Ricerca (discovery) di dispositivi, 
	\item Query su una lista di dispositivi connessi,
	\item istanziazione di un dispositivo Bluetooth (\verb|BluetoothDevice|) usando un indirizzo MAC noto,
	\item creazione di una server-socket (\verb|BluetoothServerSocket|) per accettare richieste di connessione da altri dispositivi Bluetooth.
\end{itemize}
\subsection{Gestione della connessione}
\verb|ConnectThread| è un \verb|\Runnable| che gestisce le connessioni mediante thread. Dati un dispositivo \verb|BluetoothDevice|, un adattatore \verb|BluetoothAdapter| ed il numero identificativo del dispositivo, 
se questo non è connesso, viene creata una socket RFComm con l'UUID pronta per una comunicazione. All'avvio del thread (con il metodo \verb|run()|) avviene la connessione. Il thread lancia a sua volta un thread al quale delega la gestione delle socket create (\verb|manageConnectedSocket|). Quest'ultimo invia un segnale di inizio acquisizione dati sui canali creati e li acquisisce se disponibili.

\subsection{Gestione Thread}
Il sistema operativo Android è multithread. Un applicativo che risponda rapidamente alle richieste dell'utente deve necessariamente smistare i compiti a più thread, dando la precedenza ai thread di risposta all'utente. Il più importante di questi è lo UI Thread (User Interface Thread). Una regola di base della programmazione di applicativi Android è, nella creazione di un'activity, che si deve assolutamente evitare di sovraccaricare, o ancora peggio, eseguire istruzioni potenzialmente bloccanti all'interno dello UI Thread. La prassi per la gestione di operazioni con un comportamento imprevedibile dal punto di vista temporale, come ad esempio le operazioni di rete o di lettura e scrittura di file, è di incaricare altri thread che possano, se necessario, essere eseguiti in background, o fermati se necessario.\\
Abbiamo ritenuto utile avere un protocollo di comunicazione fra thread mediante una struttura che abbiamo chiamato "mailbox", in cui $n$ thread possano inserire e consumare dati.\\
\subsubsection{MailBox}
\label{sec:mailbox}
L'oggetto \verb|MailBox| è un buffer di tipo generico, a cui si può accedere per ora solo mediante un inserimento ed un prelievo sincronizzati, ma ciò potrebbe essere facilmente esteso a 3 modalità:
\begin{enumerate}
	\item \textbf{Sincronizzata}: l'inserimento e prelievo di dati dalla mailbox è bloccante, un thread inserisce un dato se c'è spazio nel buffer, un altro thread utilizza il dato, se esiste. Ciascuno attende il proprio turno per compiere l'azione. La sincronizzazione viene gestita con un meccanismo di semafori che Java fornisce.
	I metodi di accesso sono:

	
\begin{lstlisting}[language=java, style=eclipse,label=code:mailbox_put_get]
	synchronized public void put(T object)
	synchronized public T get()
\end{lstlisting}


	Un thread alla volta può prendere, in mutua esclusione, l'accesso in scrittura al buffer, chiamando per primo il metodo \verb|put| (vedi algoritmo \ref{alg:mailbox_put}). Il valore contenuto nel buffer è sempre visibile a tutti i thread. Questo risultato è stato ottenuto dichiarando la variabile con la parola chiave \verb|volatile|. 
\begin{lstlisting}[language=java, style=eclipse]
	volatile private T buffer = null;
\end{lstlisting}
Normalmente, ciò che avviene al momento in cui un thread prende l'accesso in mutua esclusione ad una variabile, è che si copia nel proprio stack di lavoro la variabile e modifica quella e solo prima di rilasciare la variabile la aggiorna all'esterno. Altri thread che fossero abilitati a vedere la variabile nel momento in cui è in modifica, vedrebbero un valore incongruente con il valore reale della stessa. La parola chiave volatile, impedisce ai thread che la modificano di crearsene una copia, e li vincola a lavorare direttamente sulla variabile\footnote{la parola chiave volatile impedisce un possibile ripristino del valore di una variabile, il che rende potenzialmente pericolosa per la perdita di dati} garantendone la visibilità in tutti i momenti.\\ 

\begin{lstlisting}[language=java, style=eclipse,label=code:mailbox_put]
synchronized public void put(T object){
	//se il buffer è vuoto
	if (buffer == null){
		//inserisci l'oggetto
		buffer = object;
		//notifica tutti i thread in attesa sul buffer
		this.notifyAll();
	}else{
		try{
			//altrimenti attendi una notifica sul buffer
			this.wait();
			buffer = object;				
		}catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
\end{lstlisting}
 

Un thread può prelevare il dato immesso da un altro nella mailbox, usando il metodo \verb|get()|(vedi algoritmo \ref{alg:mailbox_get}). Mentre il dato viene prelevato, questo non può essere modificato. Appena il thread ha preso il dato, lo elimina dal buffer.

\begin{lstlisting}[language=java, style=eclipse,label=code:mailbox_get]
synchronized public T get(long d){
	T temp = null;
	//il buffer è vuoto
	if(buffer == null){
		try {
			//attendi una notifica sul buffer
			this.wait();
			//salva il contenuto del buffer
			temp = buffer;
			//svuoto il buffer
			buffer = null;
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	} else {
		temp = buffer;
		buffer = null;			
		//notifica tutti i thread in attesa sul buffer
		this.notifyAll();
	}
	return  temp; }
\end{lstlisting}

Queste due operazioni implicano che devono essere eseguite in ordine, ed alternati ($put(dato_i)$, $get()$, $put(dato_j)$, $get()$ ecc ).

\item \textbf{Temporizzata}: ciò che avviene è molto simile al caso precedete: i thread vengono sincronizzati sul buffer. La differenza è che attendono solo una predeterminata quantità di tempo prima di inserire dati nuovi nel buffer. Ciò significa che sovrascrivono qualunque dato non sia stato consumato in tempo.

\item \textbf{Condizionata}: la variante, in questo caso, sta nel superare l'attesa in scrittura nel momento in cui si verifichi una determinata condizione. 

\end{enumerate}


\subsubsection{Test per il protocollo di comunicazione MailBox}

Il primo esperimento riuscito sul protocollo è stato quello di due thread, un produttore ed un consumatore che comunicano tramite una \verb|MailBox|. Il produttore genera una sequenza ordinata di numeri dispari, crea un oggetto \verb|Point| nel seguente modo:
\begin{lstlisting}[language=java, style=eclipse,caption=Creazione di un oggetto Point,label=code:mailbox_experiment]
new Point(x++, Math.sin(x))
\end{verbatim}

L'oggetto così creato viene inserito dallo stesso produttore nella MailBox. Il consumatore può tentare di prelevare l'oggetto chiamando \verb|get()|. Mandando in stampa su console una sessione di comunicazioni si ha:

\begin{table}%
\centering
\begin{tabular}{l l}
put:& (70913.0, 0.921)\\
get:& (70913.0, 0.921)\\
put:& (70915.0, -0.737)\\
get:& (70915.0, -0.737)\\
put:& (70917.0, -0.307)\\
get:& (70917.0, -0.307)\\
put:& (70919.0, 0.993)\\
get:& (70919.0, 0.993)\\
put:& (70921.0, -0.519)\\
get:& (70921.0, -0.519)\\
put:& (70923.0, -0.561)\\
get:& (70923.0, -0.561)\\
put:& (70924.0, 0.393)
\end{tabular}
\caption{Sequenza di scritture su console da parte di un thread che crea la coppia (x, sin(x)) e da un altro che consuma il valore usando il protocollo MailBox}
\end{table}
 
Ho reimplementato lo stesso esperimento su Android, con una semplice activity per visualizzare il punto generato dal thead produttore, come il centro di un cerchio.
\begin{figure}
	\centering
		\includegraphics[width=.6\textwidth]{imgs/MailBoxCommTestAndroid.jpg}
	\caption{Prova di funzionamento del protocollo di comunicazione fra thread implementato su Android}
	\label{fig:mailbox_comm_test_android}
\end{figure}

\subsection{HMM}
L'interfaccia \verb|HiddenMarkovModel| è pensata per fornire uno scheletro per tutti i tipi di HMM. 
Chi implementa l'interfaccia, dovrebbe partire dalla creazione di un insieme di stati $S$ ed un insieme di simboli di osservazione $V$. A questo punto le dimensioni delle strutture dati che conterranno i parametri sono note, e le implementazioni dei seguenti metodi accessori agli stessi dovrebbero assicurarsi che vengano rispettate tali dimensioni.
\begin{itemize}
	\item \verb|setA(ArrayList<Object> mtx)|, \verb|getA()|: rendere accessibile la matrice di transizioni
	\item \verb|setB(ArrayList<Object> mtx)|,  \verb|getB()|: rendere accessibile la matrice di emissioni
	\item \verb|setPi(ArrayList<Double> vec)|, \verb|getPi()|rendere accessibile il vettore di prior
	\item \verb|areValidObservations(ArrayList<Object> observations)|, chi implementa l'interfaccia potrebbe anche decidere di verificare la validità di una nuova osservazione, verificandone l'appartenenza all'insieme delle osservazioni.
\end{itemize}
\subsubsection{Scheletro di un HMM}
Una prima implementazione dell'interfaccia è la classe \verb|HMM| che obbliga chi la vuole usare ad implementarla solo passando al costruttore un insieme di stati. Questo viene ottenuto rendendo privato il costruttore di default
\begin{lstlisting}[language=java, style=eclipse, caption=Costruttori HMM , label=code:hmm1]
private HMM() {...}
public HMM(HashMap<String, Object> states) {...}
\end{lstlisting}
L'assegnazione dei parametri avviene solo dopo una serie di controlli sui dati in ingresso che mirano a garantire una serie di proprietà degli stessi.\\
Assegnazione della matrice di transizioni(vedi codice \ref{code:HMM_setA}): \\per prima cosa la matrice deve essere quadrata con dimensione pari al numero di stati. Successivamente a tale verifica si deve verificare la validità dei valori di probabilità di transizione per ciascuna coppia di stati, nonché la loro completezza come alternative probabilistiche (vale a dire che la loro somma è uguale a 1). Questa è un operazione costosa, ma necessaria, per garantire un minimo di correttezza.

\lstset{language=Java, basicstyle=\ttfamily,keywordstyle=\color{javapurple}\bfseries,
backgroundcolor=\color{lightBlue},stringstyle=\color{javared},commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},numbers=left,numberstyle=\tiny\color{black},
stepnumber=1,numbersep=10pt,tabsize=4,showspaces=false,showstringspaces=false,
frame=single,frameround=fttt, captionpos=b, breaklines=true,breakatwhitespace=false}
\begin{lstlisting}[caption=Impostazione della matrice di transizione, label=code:hmm_setA]
public void setA(ArrayList<Object> mtx) {
		boolean isFitTransitionMtx = true;
		
		if (mtx != null && 	
				// la matrice di transizione deve essere quadrata 
				// della cardinalità e della stessa dimensione
				// dell'insieme degli stati
				mtx.size() == S.size() && 
			 ((ArrayList<Object>) mtx.get(0)).size() == S.size()) {
			 
			// ogni elemento della matrice deve essere un valore
			// di probabilità valido: 
			for (int i = 0; i < S.size(); i++){
				isFitTransitionMtx &= 
					StatisticsOperations.areCompleteProbabilisticAlternatives((ArrayList<Object>) transitionsMtx.get(i)); 
			}
			// solo a questo punto assegno i valori alla matrice
			if (isFitTransitionMtx){
				A = transitionsMtx;
			}
		}else {
			//lancio un errore oppure
			//forzo l'utente a inizializzare 
			//A correttamente
		}
	}
\end{lstlisting}

La stessa procedura viene eseguita per l'assegnazione delle prior (vedi codice \ref{code:HMM_setPI}):
\begin{lstlisting}[caption=Impostazione del vettore delle prior, label=code:HMM_setPI]
public void setPI(ArrayList<Object> prior) {
	if (prior != null && 
			prior.size() == S.size() && 
			StatisticsOperations.areCompleteProbabilisticAlternatives(prior)){
		PI = prior;
	} else {
		//lancio un errore oppure
		//forzo l'utente a inizializzare 
		//A correttamente
	}		
}
\end{lstlisting}

L'implementazione delle matrici di emissione è delegato a HMM specializzate, ad emissioni discrete o continue. 
\subsubsection{HMM ad emissioni discrete}
Un'implementazione concreta di un HMM (utilizzabile come oggetto) è quella della HMM ad emissioni discrete
\begin{lstlisting}[caption=Firma della classe HMM ad emissioni discrete, label=code:DiscreteHMM_B]
public class DiscreteHMM extends HMM {...}
\end{lstlisting}
Questa eredita dalla classe \verb|HMM| tutto ciò che contiene, e fornisce una sua implementazione della matrice di emissioni (vedi codice \ref{code:DiscreteHMM_B}). Anche in questo caso vengono eseguiti dei controlli sui valori che vengono assegnati: la dimensione della matrice di emissioni $B:N \times M$ dove $N=|S|$ (Cardinalità dell'insieme degli stati dell'HMM) e $M=|V|$ cardinalità dell'insieme dell'alfabeto di osservazioni; i valori assegnati forniscono un'insieme completo di alternative probabilistiche.

\begin{lstlisting}[caption=Impostazione della matrice di emissioni, label=code:DiscreteHMM_B]
public void setB(ArrayList<Object> mtx) {
		boolean isFitEmissionMtx = true;
		// il numero di righe della matrice di 
		// emissione deve essere pari al numero di stati
		if (mtx != null && 
				mtx.size() == S.size()&& 
			// il numero di colonne di mtx essere
			// pari al numero di simboli osservabili
			((ArrayList<Object>) mtx.get(0)).size() == V.size()) {
			for (int i = 0; i < S.size(); i++) {
				// la somma di tutte le probabilità di osservazione
				// deve essere pari a 1
				isFitEmissionMtx &= StatisticsOperations
						.areCompleteProbabilisticAlternatives((ArrayList<Object>) mtx
								.get(i));
			}
			if (isFitEmissionMtx) {
				B = mtx;
			}
		} else {
			//lancio un errore oppure
			//forzo l'utente a inizializzare 
			//B correttamente
		}
}
\end{lstlisting}



\subsubsection{HMM ad emissioni continue}
L'implementazione della HMM ad emissioni continue, nella gerarchia di classi, è un'altra diramazione a partire dalla classe \verb|HMM|. Una HMM ad emissioni continue ha una distribuzione di probabilità sulle emissioni. Dato che la distribuzione più comunemente utilizzata è quella Gaussiana (o Normale), è stata implementata una classe con tale distribuzione.
\begin{lstlisting}[caption=Firma della classe HMM ad emissioni continue, label=code:NormalHMM]
public class NormalHMM extends HMM 
\end{lstlisting}

\subsubsection{Operazioni sulle HMM}
La classe di base che gestisce le operazioni sulle HMM discrete è 
\begin{lstlisting}[caption=Firme dell'operatore delle HMM, label=code:HMM_operations]
public class HMMOperations
\end{lstlisting}
Questa permette di eseguire gli algoritmi più importanti sulle HMM, come l'algoritmo Forward-Backward (vedi Appendice \ref{alg:fwd}, \ref{alg:bckwd}), l'algoritmo di Viterbi (vedi Appendice \ref{alg:viterbi}) e la sua variante offline.
  
Per le operazioni sulle HMM continue la classe che implementa gli algoritmi sopra menzionati è 
\begin{verbatim}
ContinuousHMMOperations
\end{verbatim}

Dopo aver creato ed inizializzato una \verb|NormalHMM|, si può richiamare ad esempio la segmentazione nel seguente modo:
\begin{lstlisting}[caption=Applicazione dell'operatore su HMM, label=code:contHMMOp]
	// creo l'HMM ed il suo operatore 
	ContinuousHMMOperations contHMMOp
	NormalHMM nHMM
	...
	// qui creo i parametri 
	// states, A, Pi, emissionMtx
	...
	// inizializzo la HMM
	// con i parametri creati
	nHMM = new NormalHMM(states);
	nHMM.setA(A);
	nHMM.setPI(Pi);
	nHMM.setContB(emissionMtx);
	//collego l'oeratore con l'HMM
	contHMMOp = new ContinuousHMMOperations(nHMM);
	...
	// un modo per acquisire osservazioni di 
	// prova è di leggerli da un file
	observation = reader.readLine()
	...
	// finalmente eseguo la segmentazione
	contHMMOp.onlineViterbi(observation)
\end{lstlisting}
